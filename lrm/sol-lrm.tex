\documentclass[letterpaper,12pt]{article}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%enumitem to itemize nicely
\usepackage{enumitem}

%source code highlighting
\usepackage{listings}

\lstset{
	breaklines=true
}

\begin{document}

%% Title, authors and addresses

\title{{\small better call} {\Huge \textbf{SOL}}\\
    \begin{center}{SHAPE ORIENTED LANGUAGE REFERENCE MANUAL}\end{center}
}


\author{Aditya Naraynamoorthy\\
    \texttt{an2753}
    \and
    Erik Dyer\\
    \texttt{ead2174}
    \and
    Gergana Alteva\\
    \texttt{gla2112}
    \and
    Kunal Baweja\\
    \texttt{kb2896}}

%% Generate the title
\maketitle

%% Table of contents
\tableofcontents

\section{Introduction}
%% Text of abstract
SOL is a simple language that allows programmers to create 2D animations with ease. Programmers will have the ability to define and create objects, known as shapes, and dictate where they appear, and how they move. As a lightweight object-oriented language, SOL allows for unlimited design opportunities and eases the burden of animation. In addition, SOL’s simplicity saves programmers the trouble of learning complicated third-party animation tools, without sacrificing control over behavior of objects.
\par

\section{Conventions}
The following conventions are followed throughout this SOL Reference Manual.

    \begin{enumerate}
        \itemsep0em
        \item \texttt{literal} - Fixed space font for literals such as commands, functions,\\
        \hspace*{4.4em} keywords, and programming language structures.
        
        \item \textit{variable} - The variables for SOL progamming language and words or\\
        \hspace*{4.4em} concept being defined are denoted in italics.
    \end{enumerate}

\section{Lexical Conventions}

This section describes the complete lexical conventions followed for a syntactically correct SOL program, forming various parts of the language.

    \subsection{\textit{Comments}}
    Comments in SOL start with character sequence \texttt{/*} and end at character sequence \texttt{*/}. They may extend over multiple lines and all characters following \texttt{/*} are ignored until an ending \texttt{*/} is encountered.

    \subsection{\textit{Identifiers}}
    In SOL, an identifier is a sequence of characters from the set of english alphabet, arabic numerals and underscore (\_). The first character cannot be a digit. Identifiers are case sensitive. Identifiers cannot be any of the reserved keywords mentioned in section \ref{keywords}.

    \subsection{\textit{Keywords}} \label{keywords}
    Keywords in SOL include data types, built-in functions, and control statements, and may not be used as identifiers as they are reserved.

        \begin{center}
            \begin{tabular}{ |c|c|c|c| } 
            \hline
                int     & if            & main          & shape \\ 
                float   & while         & setFramerate  & parent\\ 
                char    & func          & translate     & extends\\
                string  & construct     & rotate        & \\
                        & return        & render        & \\
                        &               & wait          & \\
                        &               & drawPoint     & \\
                        &               & drawCurve     & \\
                        &               & print         & \\
                        &               & length        & \\
                        &               & consolePrint  & \\
            \hline
            \end{tabular}
        \end{center}

    \subsection{\textit{Integer Constants}}
    A sequence of one or more digits representing a number in \textit{base-10}\\
    Eg: \texttt{1234}

    \subsection{\textit{Float Constants}}
    Similar to an integer, a float has an \textit{integer}, a decimal point (\texttt{.}), and a fractional part. Both the integer and fractional part are a sequence of one or more digits.\\
    Eg: \texttt{0.55  10.2}

    \subsection{\textit{Character Constants}}
    An ASCII character within single quotation marks.\\
    Eg: \texttt{'x' 'a'}

    \subsection{\textit{Escape Sequences}}
    The following are special characters represented by escape sequences.
        \begin{center}
            \begin{tabular}{ |c|c| }
            \hline
                \textbf{Name}   & \textbf{Escape}\\
                \hline
                newline         & \textbackslash n\\
                tab             & \textbackslash t\\
                backslash       & \textbackslash \textbackslash\\
                single quote    & \textbackslash '\\
                double quote    & \textbackslash "\\
                ASCII NUL character & \textbackslash 0\\
            \hline
            \end{tabular}
        \end{center}

    \subsection{\textit{String constants}}
    A SOL \textit{string} is a series of \textit{characters} within double quotation marks. Its type is an array (defined in ) of characters. The compiler places a null byte (\texttt{\textbackslash0}) at the end of a string literal to mark its end.\\
    Eg: \texttt{“cat”}

	\subsection{\textit{Operators}}
    SOL has mainly four categories of operators defined below:

        \subsubsection{\textit{Assignment Operator}}
        An \textit{assignment operator} is denoted by the \texttt{=} symbol having a variable identifier to its left and a valid expression on its right. The \textit{assignment operator} of the expression on the right to the variable on the left.

        \subsubsection{\textit{Arithmetic Operators}}
        SOL has following \textit{binary arithmetic operators}. A \textit{binary arithmetic operator} operates on two \textit{arithmetic expressions} specified before and after the operator respectively. The said expressions must be of type \textit{int} or \textit{float}

            \begin{center}
                \begin{tabular}{ |c|c| }
                \hline
                    \textbf{Operator} & \textbf{Definition} \\
                    \hline
                    +   &   Addition\\
                    -   &   Subtraction\\
                    *   &   Multiplication\\
                    /   &   Division\\
                    \%  &   Modulo\\
                \hline
                \end{tabular}
            \end{center}

        \subsubsection{\textit{Comparison Operators}}
        The comparison operators are binary operators for comparing values of operands defined as expressions.
            \begin{center}
                \begin{tabular}{ |c|c| }
                \hline
                    \textbf{Operator} & \textbf{Definition} \\
                    \hline
                    ==  & Equality \\
                    !=  & Not Equals \\
                    <   & Less than \\
                    >   & Greater than \\
                    <=  & Less than or equals \\
                    >=  & Greter than or equals \\
                \hline
                \end{tabular}
            \end{center}
        
        \subsubsection{\textit{Logical Operators}}
        The logical operators evaluate boolean expressions and return an integer as the result - with 0 as False and 1 as True. The AND (\&\&) and OR ($||$) operators are binary, while the NOT (!) operator is unary.
	        \begin{center}
	        	\begin{tabular}{ |c|c| }
	        		\hline
	        		\textbf{Operator} & \textbf{Definition} \\
	        		\hline
	        		\&\&  & AND \\
	        		$||$  & OR \\
	        		!  & NOT \\
	        		\hline
	        	\end{tabular}
	        \end{center}

	\subsection{\textit{Punctuators}}
	The following symbols are used for semantic organization in SOL:
	     \begin{center}
	     	\begin{tabular}{ |p{0.25\hsize}|p{0.75\hsize}| }
	     		\hline
	     		\textbf{Punctuator} & \textbf{Usage} \\
	     		\hline
	     		\{\}			& Used to denote a block of code. Must be present as a pair. \\
	     		()				& Specifies conditions for statements before the subsequent code, or denotes the arguments of a function. Must be present as a pair. \\
	     		\lbrack\rbrack	& Indicates an array. Must be present as a pair. \\
	     		;				& Signals the end of a line of code. \\
	     		,				& Used to separate arguments for a function, or elements in an array definition. \\
	     		\hline
	     	\end{tabular}
	     \end{center}
	
\section{Identifier Scope}
	\subsection{\textit{Block Scope}}
	Identifier scope is a specific area of code wherein an identifier exists. A scope of an identifier is from its declaration until the end of the code block within which it is declared.
	
	\subsection{\textit{File Scope}}
	Any identifier (such as a variable or a function) that is defined outside a code block has file scope i.e. it exists throughout the file.
	
	If an identifier with file scope has the same name as an identifier with block scope, the block-scope identifier gets precedence.

\section{Expressions and Operators}
	\subsection{\textit{Typecasting}}
	A typecast is the conversion a variable from one type to another. SOL supports explicit casting of ints to floats and floats to ints. To cast a variable to a different type, place the desired type in parentheses in front of the variable. \\
	Eg: \texttt{(int) myFloat}
	
	\subsection{\textit{Precedence and Associativity}}
	SOL expressions are evaluated with the following rules:
	\begin{itemize}
		\item Expressions are evaluated from left to right
		\item Multiplication, division and modulo operations take precedence over addition and subtraction
		\item Parentheses override all precedence rules
		\item Logical NOT has precedence over logical AND, which has precedence over logical OR
	\end{itemize}
	
	\subsection{\textit{Dot Accessor}}
	To access members of a declared \texttt{shape} (further described in section \ref{classes}), use the dot accessor ‘.’. \\
	Eg: \texttt{shape\_object.point1 /* This accesses the variable point1 within the object shape\_object */}


\section{Declarations}

    Declarations determine how an identifier should be interpreted by the compiler. A declaration should include the identifier type and the given name

    \subsection{\textit{Type Specifiers}} \label{type}
    SOL provides four type specifiers for data types:
    \begin{itemize}
        \itemsep0em
        \item \texttt{int} - integer number
        \item \texttt{float} - floating point number
        \item \texttt{char} - a single character
        \item \texttt{string} - string (ordered sequence of characters)
    \end{itemize}

	\subsection{\textit{Array Declarators}} \label{array}
    An array may be formed from any of the primitive types and shapes, but each array may only contain one type of primitive or shape. At declaration, the type specifier and the size of the array must be indicated. In a function signature, the size of the array should not be specified. Arrays are most commonly used in SOL to specify coordinates with two integers.\\
    Eg: \texttt{int[2] coor; /* Array of two integers */}

    \subsection{\textit{Function Declarators and Definition}}
    Functions are declared with the keyword: \texttt{func}. This is followed by the \textit{return type} of the function. If no return type is specified, then the function automatically returns nothing. Functions are given a name (which is a valid identifier) followed by function arguments. These arguments are a comma-separated list of variable declarations within parentheses. Primitives are passed into functions by value, and objects and arrays are passed by reference. This function declaration is then followed by the function definition, within curly braces; functions must always be defined immediately after they are declared.\\
    Eg: \begin{lstlisting}[aboveskip=-13pt]
        func example(int a, int b){
            /* a function named ‘example’ that takes two arguments that are both of type int */
        }
    \end{lstlisting}

    \subsection{\textit{Constructor Declarators}}
    Constructors are declared with the keyword: \texttt{construct}. Constructor definitions are similar to a function definition with two additional constraints: 
    \begin{enumerate}
        \itemsep0em
        \item Constructors are defined inside the class definition.
        \item Constructors are given the same name as the class and followed by arguments, within parenthesisas a comma-separated list of variable declarations, similar to function definitions.
    \end{enumerate}
    Eg: \begin{lstlisting}[aboveskip=-13pt]
        construct Triangle(int[] a_init, int[] b_init, int[] c_init) {
            a = a_init;
            b = b_init;
            c = c_init;
        }
    \end{lstlisting}

    \subsection{\textit{Definitions}}
    A definition of an object or type includes a value, assigned by the assignment operator \texttt{=}.\\
    Eg: \begin{lstlisting}[aboveskip=-13pt]
            int x = a;    /* declaration & definition*/
            char y;       /* declaration */
            y = 'b';      /* definition */
            float z = 3.4;
            int[3] w = [5, 2, 0];
            string f = "cats";
        \end{lstlisting}

\section{Statements} \label{classes}
A statement in SOL refers to a complete instruction for a SOL program. All statements are executed in order of sequence. The four types of statements are described in detail below:\\

\subsection{\textit{Expression Statement}}
Expression statements are the statements which get evaluated and product a result. This can be as simple as an assignment or a function call.
Eg: \texttt{int x = 5; /* assign 5 to variable x */}

\subsection{\textit{If Statement}}
An \textit{if statement} is a conditional statement. Given a condition for \textit{if statement}, if it evaluates to non-zero value then it is considered valid and the code block associated with \textit{if statment} is executed.\\
Eg: \begin{lstlisting}[aboveskip=-13pt]
        int x = 1;
        if (x == 1) {
            /* This code gets executed */
        }
    \end{lstlisting}

\subsection{\textit{While Statement}}
A \textit{while statement} specifies the looping construct in SOL. It starts with \texttt{while} keyword, followed by an expression specified within a pair of parenthesis; followed by a block of code within curly braces which is executed repeatedly as long as the condition in parentheses is valid. This condition is re-evaluated before each iteration. \\
Eg: \begin{lstlisting}[aboveskip=-13pt]
        int x = 5;
        while (x > 0) {
            /* This code gets executed 5 times */
            x = x - 1;
        }
    \end{lstlisting}

\subsection{\textit{Return statement}}
Stops execution of a function and returns to where the function was called originally in the code.  Potentially returns a value; however, the function must specify a return type, otherwise this will result in a syntax error.\\
Eg: \begin{lstlisting}[aboveskip=-13pt]
        func int sum(int x, int y) {
            /* return sum of two integers */
            return x + y;
        }
    \end{lstlisting}

\section{Internal Functions}
SOL specifies a set of required/internal functions that must be defined for specific tasks such as drawing, rendering or as an entry point to the program, described below.

\subsection{\textit{main}}
Every SOL program must contain a \texttt{main} function as this is the entrypoint of the program. The \texttt{main} function may call other functions written in the program. The \texttt{main} function does not take inputs as SOL programs do not depend on user input. The \texttt{main} function does not allow for member variables of shape objects to be changed.\\
\underline{Arguments}: None

\subsection{\textit{length}}
Returns the number of elements in an \texttt{array}.\\
\underline{Arguments}: Array of elements with same \texttt{type}

\subsection{\texttt{setFramerate}}
Defined once at the start of the program, to specify the frames rendered per second. May only be defined once.\\
\underline{Arguments}: \texttt{rate (float)}

\subsection{\texttt{consolePrint}}
Prints a string to the console. Commonly used to print error messages to the console.\\
\underline{Arguments}: \texttt{text (string)}


\section{Drawing Functions}
The following set of functions are also a category of internal/required functions, which describe the drawing aspects for objects defined in an SOL program.

\subsection{\textit{drawPoint}}
Draws a point at a specified coordinate in the specified color.\\
\underline{Arguments}: \texttt{pt (int[2]), color (int[3])}

\subsection{\textit{drawCurve}}
Draws a Bezier curve in the specified color defined by three coordinates, which are the three control points.\\
\underline{Arguments}: \texttt{pt1 (int[2]), pt2 (int[2]), pt3 (int[2]), color (int[3])}

\subsection{\textit{print}}
Displays text onto the render screen at the coordinates specified by the user, in the specified color.\\
\underline{Arguments}: \texttt{pt (int[2]), text (string), color (int[3])}



\section{Animation Functions} \label{animation}
The following functions are used to animate the objects drawn in an SOL program.

\subsection{\textit{translate}}
Displaces a shape by specifying a two element array integers, where the first element is the number of pixels along the horizontal axis and the second element along the vertical axis, over a specified time period in seconds.\\
\underline{Arguments}: \texttt{displace (int[2]) /* horizontal, vertical */}

\subsection{\textit{rotate}}
Rotate a shape around an axis point by a specified number of degrees over a time period in seconds.\\
\underline{Arguments}: \texttt{axis (int[2]), angle (float), time (float)}

\subsection{\textit{render}}
Specify the set of motions to be animated using SDL. This code-block can be defined for shapes that need to move or can be left undefined for non-moving shapes. Within this function, various \texttt{rotate} and \texttt{translate} calls can be made to move the shape. This should be specified in the \texttt{main} function\\
\underline{Arguments:} None

\subsection{\textit{wait}}
Pauses animation for a specified amount of time (in seconds). To be called in the \texttt{render} function.\\
\underline{Arguments}: \texttt{time (float)}


\section{Classes}
SOL follows an object-oriented paradigm for defining objects (drawings) which can be further animated using the animation functions described in \ref{animation}.

\subsection{\textit{shape}}
Similar to a class in C++; a shape defines a particular 2-D shape as part of the drawing on screen. Every \texttt{shape} has a user defined \texttt{draw} function that specifies how shapes are statically rendered, using multiple \texttt{drawPoint}, \texttt{drawCurve} and \texttt{print} commands. This is the base class in SOL, and all classes created by the programmer extend this class. The class may contain multiple member variables that could be used to draw the shape. These member variables are defined in a constructor, specified by the keyword \texttt{construct}. It is also possible to declare member functions for a shape. When member variables are accessed within a member function, it is implied that the member variables belong to the current object that calls the function.\\
Once a shape object has been instantiated, these member variables cannot be changed, but may still be accessed later, using the dot accessor, '.'.\\
Eg: \begin{lstlisting}[aboveskip=-13pt]
        shape Triangle {
            int[2] a;
            int[2] b;
            int[2] c;
            construct Triangle(int[] a_init, int[] b_init, int[] c_init) {
                a = a_init;
                b = b_init;
                c = c_init;
            }
        
            func int[] findCentre(int[] x, int []y) {
                if(length(a) != length(b)) {
                    consolePrint("Arrays size mismatch. Abort");
                    return int[0];
                }
            
                int i = 0;
                int c[length(a)];
                while(i < length(x)) {
                    c[i] = a[i] + b[i] / 2;
                }
                return c;
            }

            func draw() {
                /* Draw lines between the three vertices of the triangle */
                drawcurve(a, findCentre(a, b), b, [0, 0, 0]);
                drawcurve(b, findCentre(b, c), c, [0, 0, 0]);
                drawcurve(c, findCentre(c, a), a, [255, 255, 255]);
            }
        }
    \end{lstlisting}

\subsection{\textit{Inheritance}}
SOL allows single class inheritance for shapes i.e given a shape, such as \texttt{Line}, one may create a sub-shape of \texttt{Line}, called \texttt{LineBottom}, and inherit all of its fields from the super-shape, \texttt{Line}, using the keyword \texttt{extends}.\\

Eg: \begin{lstlisting}[aboveskip=-13pt]
        shape Line {
            int[2] a;
            int[2] b;
            
            construct Line(int[] a_init, int[] b_init) {
                a = a_init;
                b = b_init;
            }
    
            func int[] findCentre(int[] x, int[] y) {
                if(length(a) != length(b)) {
                    consolePrint("Arrays size mismatch! Abort !");
                    return int[0];
                }
        
                int i = 0;
                int c[length(a)];
                while(i < length(x)) {
                    c[i] = a[i] + b[i] / 2;
                }
                return c;
            }
            
            func draw() {
                drawcurve(a, findCentre(a, b), b, [0, 0, 0]);
            }
        }

        /* Subclass of Line */
        shape LineBottom extends Line {
            int[2] c;
            int[2] d;
    
            construct LineBottom(int[] a_init, int[] b_init, int[] c_init) {
                parent(a_init, b_init);
                c = c_init;
                d = b;
            }
    
            func draw() {
                parent();
                drawcurve(c, findCentre(c, d), d, [0, 0, 0]);
            }
        }
    \end{lstlisting}

    \subsubsection{\textit{parent (keyword)}}
    The super-shape's functions can be accessed through the keyword \texttt{parent} followed by a \texttt{dot operator} and the member function name. This invokes the implementation of the member function defined in the super-shape. In constructors, the \texttt{parent()} calls the constructor for the super-shape.

\end{document}

%%
%% End of file `elsarticle-template-1-num.tex'.