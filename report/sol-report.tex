%%Author: Javangers Team

\documentclass[letterpaper,12pt]{report}

%% page layouts
\usepackage[margin=0.8in]{geometry}

%% appendices
\usepackage[toc,page]{appendix}

%enumitem to itemize nicely
\usepackage{enumitem}

%source code highlighting
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{xcolor}

\usepackage[hidelinks]{hyperref}
\hypersetup{
    linktoc=all,     %sections and subsections linked
    urlcolor=blue
}

% display backtick
\usepackage{upquote}

% import images
\usepackage{graphicx}

\definecolor{lightgray}{rgb}{.95,.95,.95}

% gnu make listing
\lstdefinestyle{bash}{
   language=bash,
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-4pt
}

% gnu make listing
\lstdefinestyle{make}{
   language=[gnu]make,
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-4pt
}

% ocaml listing
\lstdefinestyle{caml}{
   language=[Objective]Caml,
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-4pt
}

% settings for SOL code listings
\lstdefinestyle{sol}{
   language=Java,
   morekeywords={func, construct, shape, string},
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-10pt
}

\begin{document}

%% Title, authors and addresses
\title{{\small better call} {\Huge \textbf{SOL}}\\
    \begin{center}{SHAPE ORIENTED LANGUAGE FINAL REPORT}\end{center}
}

\author{
\begin{tabular}{ lc lc lc }
Aditya Narayanamoorthy & \texttt{an2753}  & \textit{Language Guru}    \\
Erik Dyer              & \texttt{ead2174} & \textit{System Architect} \\
Gergana Alteva         & \texttt{gla2112} & \textit{Program Manager}  \\
Kunal Baweja           & \texttt{kb2896}  & \textit{Tester}
\end{tabular}
}

%% Generate the title
\maketitle

%% Table of contents
\tableofcontents{}

\chapter{Introduction}
  SOL (Shape Oriented Language), is a domain specific programming language that allows programmers to create 2D animations with ease, through an object-oriented approach. Engineers, programmers, scientists and designers, through SOL, have the ability to define and create objects, known as Shapes, and dictate their appearance and movements on the screen. SOL\'s simplicity saves developers the trouble of learning complicated third-party animation tools, without sacrificing control over behavior of objects. It compiles into LLVM IR bytecode, making it adaptable across different architectures. The produced LLVM IR bytecode can be translated further into assembly code and linked statically against a predefined library before compiling down into an executable for a specific architecture using the LLVM compiler and GCC compilers respectively. The predefined library used by SOL for graphic rendering has been built on top of SDL2, that abstracts away the lower level details for drawing and animating objects.

  \section{Background}
  SOL takes its inspiration from the ease of programming in \textit{object-oriented paradigm} and the complexity of existing libraries/solutions for rendering graphics. It attempts to combine both of them and provide a language which allows developers to organize graphics into a collection of \textit{Shapes} (much like objects) which can be easily defined, created and interacted with to produce powerful images and/or animations at a fast paced development.\\

  SOL is commonly used to model various types of scientific data, but it can also be applicable in other domains, such as:
  \begin{enumerate}
    \itemsep 0em
    \item Drawing engineering models
    \item Data visualization
    \item Bored college students making funny memes
    \item Entertaining animations
  \end{enumerate}

\chapter{Language Tutorial}
  This chapter provides a simple language tutorial to guide programmers towards creating their first SOL program! It has been divided into three parts:
  \begin{enumerate}
    \item \textbf{Environment setup} - guide to setting up the SOL compiler and development environment
    \item \textbf{Language Quick Tour} - a bried descriptioin of basic components of language.
    \item \textbf{Sample Program} - create and rotate a line about its midpoint
  \end{enumerate}

  \section{Environment setup}
  SOL compiler has been developed and tested on Ubuntu 15.04 and Ubuntu 16.04 environments, and capable of supporting others as well. It can work on multiple architecture as the LLVM IR bytecode can further be compiled into architecture specific executables. The environment setup tutorial assumes you have the latest version of SOL compile source code downloaded from our repository.

    \subsection{Building SOL compiler (Ubuntu 15.04 or later version)}
    \begin{enumerate}
      \item SOL compiler is written in OCaml. Download the source code from our github repository: \colorbox{lightgray}{{\href{https://github.com/bawejakunal/sol}{https://github.com/bawejakunal/sol}}}

      \item Download and run the bash script below, which installs the latest compatible version of OCaml compiler and opam for *-nix OS environments.\\
      \colorbox{lightgray}{{\href{https://raw.githubusercontent.com/ocaml/ocaml-ci-scripts/master/.travis-ocaml.sh}{https://raw.githubusercontent.com/ocaml/ocaml-ci-scripts/master/.travis-ocaml.sh}}}

      \item Configure the opam environment for importing Ocaml packages\\
      \colorbox{lightgray}{\lstinline[style=bash]{eval `opam config env`}}

      \item Install LLVM compiler toolchain and ocaml bindings, for the SOL compiler\\
      \colorbox{lightgray}{\lstinline[style=bash]{./install-llvm.sh}}

      \item Download and Install SDL2 and SDL2\_gfx libraries which are used by our predefined static library for graphics rendering.\\
        \colorbox{lightgray}{\lstinline[style=bash]{wget} \href{http://www.ferzkopp.net/Software/SDL2\_gfx/SDL2\_gfx-1.0.3.tar.gz}{http://www.ferzkopp.net/Software/SDL2\_gfx/SDL2\_gfx-1.0.3.tar.gz}}\\
        \colorbox{lightgray}{\lstinline[style=bash]{./install-sdl-gfx.sh}}

      \item Build the SOL compiler as \texttt{sol.native} and the static graphic libarary as \texttt{predefined.o}\\
      \colorbox{lightgray}{\lstinline[style=bash]{make all}}

    \end{enumerate}

  \section{SOL Quick Tour}
  This section provides a quick tour on the data types, data structures and the shape oriented programming paradigm provided by SOL, with examples. Towards the end we walk through the steps to generate an executable SOL program. For a detailed explanation of language syntax, semantics and built-int functions refer to chapter \ref{lrm}.

    \subsection{Primitive data types}
      All variables of primitive data types are declared starting with their type followed by an identification. SOL supports following primitives:
      \begin{enumerate}
        \itemsep 0em
        \item \texttt{int} - integers
        \item \texttt{float} - double precision floating point number
        \item \texttt{char} - single character from \texttt{ASCII} character set
        \item \texttt{string} - a sequence of one or more \texttt{ASCII} characters
      \end{enumerate}
      Example:\\
      \begin{lstlisting}[style=sol]
        func main() {
            int x;  /* declare primitives */
            float y;
            char c;
            string s;

            x = 5;  /* assign values to primitives */
            y = 6.5;
            c = 'a';
            s = "better call SOL";
        }
      \end{lstlisting}

    \subsection{Arrays and Shapes}
      SOL supports two complex data structures:
      \subsubsection{Array}
        An array is a fixed size sequence of primitives. Individual elements can be accessed within array by specifying indices as integers in range \texttt{0} to \texttt{1 less than array length}.\\
        Example:\\
        \begin{lstlisting}[style=sol]
          func main() {
              int [3]a;      /* declare array of 3 integers */
              a = [1, 2, 3]; /* init array with 3 elements*/
              a[1] = 4;      /* update second element value to 4 */
              a[2] = a[0];   /* last element equal to first element */
          }
        \end{lstlisting}

      \subsubsection{Shape}
        A collection of one or more variables of \textit{primitives, arrays and/or shapes} which come together to describe a \textit{shape}. These variables are called \textit{member variables} of a shape. A shape definition can also contain function definitions, referred as \textit{member functions}.\\
        Example:\\
        \begin{lstlisting}[style=sol]
          class Line {
              string name;  /* identify a line by name */
              int [2]start; /* first end point of a line */
              int [2]end;   /* other end point of a line */

              /* compulsory constructor for a shape */
              construct(int [2]s, int[2]e) {
                  /* constructor can be empty definition */
                  start = s;
                  end = e;
              }

              /* compulsory draw member function.*/
              draw() {
                  /* accepts no arguments */
                  /* can be empty definition */
              }
          }

          func main() {
              Line l; /* declare a variable of shape Line */
              l = shape Line([1,1], [2,2]); /* instantiate a Line object */
          }
        \end{lstlisting}

    \subsection{Operators}
    SOL supports \texit{arithmetic operations, relational comparisons and logical operations}. For all binary operators described in this section, the operands are specified to the left and right, respectively, of the operator and \textit{both operands must be expressions of same data types}.\\
    All logical operators accept \textit{boolean logic expressions},represented as \textit{integer expression} in SOL. Non-zero expressions correspond to \texttt{true} and a \texttt{zero} corresponds to \texttt{false}. 

    \begin{enumerate}
      \itemsep 0em
      \item \textit{Binary arithmetic operators}: \texttt{+, -, *, / \%}
      \item \textit{Relational operators (binary)}: \texttt{==, |=, >, >=, <, <=}
      \item \textit{Logical operators}: \texttt{\&\&, ||} \textit{(operands must be of type int)}
      \item \textit{Logical not}: \texttt{!} \textit{(unary and right associative)}
      \item \textit{Unary negation}: \texttt{-} \textit{(unary and right associative)}
    \end{enumerate}

    All expressions are evaluated left to right. Please refer to section \ref{precedence} for exact order of preference and associativity rules for each operator.\\

    Example:\\
    \begin{lstlisting}[style=sol]
        func main() {
            int x;
            int y;
            int c;
            float f;
            float g;

            x = 2;
            y = 3;
            f = 3.0;
            g = 6.0;

            y = x + y;  /*5: integer addition */
            x = y - x;  /*3: subtraction */

            g = g * f;  /* 18: floating point multiplication*/
            f = g / f;  /* 6: floating point division */
            y = y % 2;  /*1: modulo operation */

            c = g == f; /*0: EQUALITY is false */
            c = g != f; /*1: NOT EQUAL is true */
            c = g > f;  /*1: g GREATER THAN f */
            c = y >= x; /*1: y GREATER THAN OR EQUAL x is true */
            c = y < x;  /*0: y LESS THAN x is false */
            c = 5 <= 5; /*1: 5 LESS THAN OR EQUALS 5 is true */

            c = 5 && 0; /*0: LOGICAL AND of true and false */
            c = 2 || 0; /*1: LOGICAL OR of true and false */

            c = !c;   /*0: LOGICAL NOT of true(1) */
            f = -f;   /*-6: unary negation of arithmetic expression */
        }
    \end{lstlisting} 

    \subsection{Control flow statements}
    SOL program statements are executed in order, with the entry point being the main function. However, sometimes developers need to execute only a branch of source code (jump through some statements) or execute a portion of code repeatedly. SOL provides two control flow statements if and while for conditional branching and looping through a portion of code, respectively.

      \subsubsection{if-statement}
      An \textit {if statement block} allows to execute or skip a \texit{code branch} based on a \textit{logical expression}.\\
      Example:\\
      \begin{lstlisting}[style=sol]
        func main() {
          if (1 > 2) {
            /* condition if false; skip this code block */
            consolePrint("NOT PRINTED");
          }
          consolePrint("Hello World");
        }
      \end{lstlisting}

      \subsubsection{while-statement}
      A \texit{while statement block} allows to execute a portion of source code repeatedly until a logical condition holds \texttt{true}.
      \begin{lstlisting}[style=sol]
        func main() {
            int i;
            i = 1;
            while (i <= 5) {
                consolePrint("Hello");  /* this loop prints Hello 5 times*/
                i = i + 1;    /* loop terminates when i exceeds 5 */
            }
        }
      \end{lstlisting}

    \subsection{Functions in SOL}
    In SOL functions can be defined as a way to abstract away and re-use a code lock, with a named representation. These are useful if a particular piece of code needs to be executed at multiple places in the program. Functions in SOL can be defined as stand alone functions or as \textit{member functions} of a \textit{shape} definition. Function definitions begin with the \texttt{func} keyword and they optionally accept arguments as input values and return a result, for which the result type needs to be indicated in the function definition. A function may not return any result (void type) in which case no return type needs to be mentioned during function definition. Please refer section \ref{function} for a detailed explanation of function definition syntax.\\
    
    Example:\\
    \begin{lstlisting}[style=sol]
      /* define a function that accepts two integers and returns their sum */
      func int add(int x, int y) {
          /* sum of two integers */
          return x + y;
      }

      func main() {
          int sum;
          sum = add(2, 3);
          if (sum == 5) {
              consolePrint("CORRECT");
          }
      }
    \end{lstlisting}

    Functions in SOL also support recursion. SOL also provides a number a of type conversion functions and built-in functions for displaying and animating shapes on screen and printing text on screen or console. Please refer to section \ref{internal} for detailed information, syntax on these functions.

  \section{Rotate a Line around midpoint (Sample SOL program)}
  The following program shows a simple example to define a line, create it and rotate it around its midpoint.
  \begin{enumerate}
    \itemsep 0em
    \item As SOL treats all animation as an interaction of \textit{shapes}, we first define a straight line as a \textit{shape} in SOL, define its \texttt{draw} function.\\
      \begin{lstlisting}[style=sol]
        shape Line {
            int [2]start;
            int [3]mid;
            int [2]end;

            construct(int [2]s, int [2]e) {
                start = s;
                end = e;
                mid[0] = (s[0] + e[0]) / 2;
                mid[1] = (s[1] + e[1]) / 2;
            }

          draw() {
            /* draw red line */
            drawCurve(start, mid, end, 100, [200, 0, 0]);
          }
        }
      \end{lstlisting}

    \item The next step is to create a line object and instantiate it within \texttt{main} function, which is the entry point to a SOL program.\\
      \begin{lstlisting}[style=sol]
        func main() {
          Line l; /* declare a line shape */

          /* create a line with given end points */
          l = shape Line([10,10], [100, 100]);

          /* rotate line here */
        }
      \end{lstlisting}
  \end{enumerate}

\chapter{Language Reference Manual} \label{lrm}

  %% include the common content for lrm
  \input{../lrm/sol-lrm-content.tex}

\chapter{Project Plan}

  This chapter details the project development, testing process, timelines, milestones and roles and responsibilities of each team member.

  \section{Project Development Process}
  Throughout the SOL compiler development process we tried to stick as closely as possible to in-lecture instructions and suggestions given by instructor, Prof. Stephen A. Edwards, and our project mentor Connor Abbott. The four major phases of project development are described in the following sections.

    \subsection{Planning}
      Once the team decided on addressing easy animations through an object-oriented programming language, we quickly got down to listing as many features as we could think of with respect to a graphics animation. As Aditya Narayanamoorthy \textit{(Language Guru)} had taken a Computer Graphics course previously, he helped us pick out the most basic and necessary features for the language, such as using \textit{B\'ezier curves} to describe shapes in our language. We tried to narrow down the minimal number of language features that would allow a SOL programmer to describe, display and animate a shape on screen using SOL. In case of a disagreement on the features to be included, the final call was taken by the \textit{Language Guru}. All the decided features are detaile in the SOL Language Reference Manual (chapter \ref{lrm}), which every team member used as a reference point for the rest of the project development and testing phases.\\

      In our planning phase we also decided on the software development process, including division of work based on each member's expertise, discussed time availabilities, tools and development environments to use, summarized below:
      \begin{enumerate}
        \itemsep 0em
        \item We scheduled two days per week for 3 hour long meetings for the team to work together on the project.
        \item Chose Github as the version control system for our project, in conjunction with Slack for team communication.
      \end{enumerate}

    \subsection{Specfication}
      For specifying the exact feature details, we required a lightweight graphics library, that would interface with the graphics backend and link well against the LLVM compiler output and develop a good understanding of its working. Erik, the systems architect, tried out a few graphics library and suggested using SDL2, primarily because of its ease of use for rendering simple graphics on screen and it's bindings of multiple languages including C, C++ and OCaml.\\

      The next major specification step for SOL programming language, was to decide on how to represent and render shapes. Aditya, our Language Guru, suggested that all shapes can be expressed as a combination of B\'ezier curves and hence the basic units of drawing in SOL, available to a programmer should be the \texttt{drawPoint} and \texttt{drawCurve} functions to draw shapes, along with \texttt{translate} and \texttt{rotate} functions to animate the drawings in a 2D plane. To accomplish drawing B\'ezier curves, on top of SDL2, we chose the SDL2\_gfx library which was compiled and integrated into the development environment by Kunal and Erik.\\

      Throughout the compiler development, we asked our mentor Connor Abbott for advice on how to prioritize  and implement features crucial for SOL, like fixed size arrays v/s dynamic arrays or advantages of using an SAST over a simple AST. During the development phase we also realized that some of the features that we had originally planned for SOL were not quite straightforward to implement, or differed from our initial understanding. This made us modify some specific components of the language, which we updated in the Language Reference Manual and testing suite, after consulting with our mentor.

    \subsection{Development and Testing}
      We followed a \textit{test driven development} approach for SOL language as far as possible. Initially test cases were written based on the features mentioned in our programming language reference manual. Test cases were divided into two main categories, features that are allowed in SOL, such as integer addition, defining shapes etc and failure cases which check whether the compiler properly rejects syntactically or semantically incorrect programs. Each test case comprised of a basic SOL program source code that would test one particular feature or component of the language and compare the actual output against an standardized file containing expected output messages.\\

      The compiler was built by integrating one feature at a time, end to end, starting at the scanner, all the way up to codegen phase and which would allow the compiler to support that feature alongside previously implemented features. Each feature implementation was tested against the test suite to ensure correct behaviour and also ensure that it does not breaks any of the previously implemented features, using the testing script and Travis CI builds that were triggered on each code push to our github repository.\\

      Towards the end of project development timeline, we also incorporated a manual testing component, as there is no way to ensure correct display of graphics within Travis CI environment. These tests can be run using the same test suite script, with manual inspection of displayed graphics to ensure correctness.\\

  \section{Programming Style Guide}
    \begin{itemize}
      \itemsep 0em
      \item Most of our compiler source code is written in OCaml, we simply used the standard Ocaml programming guidelines as mentioned on the official tutorials page\\
      \colorbox{lightgray}{\href{https://ocaml.org/learn/tutorials/guidelines.html}{https://ocaml.org/learn/tutorials/guidelines.html}}

      \item To enforce OCaml style guides, Kunal set up the open sourced merlin linter and analyzer in sublime text editor\\
      \colorbox{lightgray}{\href{https://github.com/let-def/sublime-text-merlin}{https://github.com/let-def/sublime-text-merlin}}

      \item A significant component of SOL compiler is the \textit{predefined.o} static library written in C (C99 standard) for which the C++ linter was used within sublime text.\\
      \colorbox{lightgray}{\href{ https://github.com/SublimeLinter/SublimeLinter-cppcheck}{ https://github.com/SublimeLinter/SublimeLinter-cppcheck}}

      \item As a general rule of thumb, we tried to use descriptive variable names throughout our code, which helps the reader to easily understand the code.
    \end{itemize}

  \section{Project Timeline}
    \subsection{Milestones}
      \begin{center}
        {\renewcommand{\arraystretch}{1.5}
        \begin{tabular}{|p{8cm}|p{4cm}|}
        \hline
          \textbf{Milestone} & \textbf{Date} \\
          \hline
          Initial research \& brainstorming & Sept. 11 \\
          \hline
          Decide on language idea & Sept. 19 \\
          \hline
          Finish Proposal & Sept. 26 \\
          \hline
          Finish LRM & Oct. 16 \\
          \hline
          Add regression test suite/Travis CI & Oct. 29 \\
          \hline
          Implement primitives \& other basics & Nov. 1 \\
          \hline
          Hello World Demo & Nov. 8 \\
          \hline
          Implement arrays, internal functions & Dec. 2 \\
          \hline
          Implement shapes & Dec. 12 \\
          \hline
          Implement drawing (SDL) & Dec. 16-17 \\
          \hline
          Update and Finish Testing (manual) & Dec. 17-19 \\
          \hline
          Final Report Preparation & Dec. 18-19 \\
          \hline
          Demo Day & Dec. 20\\
        \hline
        \end{tabular}
      \end{center}

    \subsection{Github timeline}
      \includegraphics[scale=0.37]{github-timeline}


% Appendix code listings
\begin{appendices}

\chapter{SOL Compiler}

Code listing for compiler code. Author names are mentioned as first comment line of each code listing.

    \section{scanner.mll}
    \lstinputlisting[style=caml]{../scanner.mll}

    \section{parser.mly}
    \lstinputlisting[style=caml]{../parser.mly}

    \section{ast.ml}
    \lstinputlisting[style=caml]{../ast.ml}

    \section{semant.ml}
    \lstinputlisting[style=caml]{../semant.ml}

    \section{sast.ml}
    \lstinputlisting[style=caml]{../sast.ml}

    \section{codegen.ml}
    \lstinputlisting[style=caml]{../codegen.ml}

    \section{sol.ml}
    \lstinputlisting[style=caml]{../codegen.ml}

    \section{predefined.h}
    \lstinputlisting[style=caml]{../predefined.h}

    \section{predefined.c}
    \lstinputlisting[style=caml]{../predefined.c}

    \section{Makefile}
    \lstinputlisting[style=make]{../Makefile}


\chapter{Environment Setup}

The following scripts can be used for installing dependencies and setting up environment.

    \section{install-llvm.sh}
    \lstinputlisting[style=bash]{../install-llvm.sh}

    \section{install-sdl-gfx.sh}
    \lstinputlisting[style=bash]{../install-sdl-gfx.sh}

\chapter{Automated testing}\label{test-suite}

The first two scripts are used for automated testing on Travis CI. For individual test cases, the author names are mentioned as first line of each test case.

    \section{.travis.yml}
    \lstinputlisting[style=bash]{../.travis.yml}

    \section{testall.sh}
    \lstinputlisting[style=bash]{../testall.sh}

    %% include latest set of automated test files
    %% use g.py scrip to generate the test-case.tex
    %% recompile the latex document
    \input{test-cases.tex}

\chapter{Manual Testing}\label{mnl-test}

  \input{manual-test.tex}

\end{appendices}

\end{document}
