%%Author: Javangers Team

\documentclass[letterpaper,12pt]{report}

%% page layouts
\usepackage[margin=0.8in]{geometry}

%% appendices
\usepackage[toc,page]{appendix}

%enumitem to itemize nicely
\usepackage{enumitem}

%source code highlighting
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{xcolor}

\usepackage[hidelinks]{hyperref}
\hypersetup{
    linktoc=all,     %sections and subsections linked
    urlcolor=blue
}

% display backtick
\usepackage{upquote}

% import images
\usepackage{graphicx}

\definecolor{lightgray}{rgb}{.95,.95,.95}

% gnu make listing
\lstdefinestyle{bash}{
   language=bash,
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-4pt
}

% gnu make listing
\lstdefinestyle{make}{
   language=[gnu]make,
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-4pt
}

% ocaml listing
\lstdefinestyle{caml}{
   language=[Objective]Caml,
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-4pt
}

% settings for SOL code listings
\lstdefinestyle{sol}{
   language=Java,
   morekeywords={func, construct, shape, string},
   keywordstyle=\bfseries\color{green!40!black},
   commentstyle=\itshape\color{purple!40!black},
   identifierstyle=\color{blue},
   extendedchars=true,
   basicstyle=\ttfamily,
   showstringspaces=false,
   showspaces=false,
   breaklines=true,
   showtabs=false,
   frame=single,
   stringstyle=\color{red},
   backgroundcolor=\color{lightgray},
   autogobble=true,
   aboveskip=-10pt
}

\begin{document}

%% Title, authors and addresses
\title{{\small better call} {\Huge \textbf{SOL}}\\
    \begin{center}{SHAPE ORIENTED LANGUAGE FINAL REPORT}\end{center}
}

\author{
\begin{tabular}{ lc lc lc }
Aditya Narayanamoorthy & \texttt{an2753}  & \textit{Language Guru}    \\
Erik Dyer              & \texttt{ead2174} & \textit{System Architect} \\
Gergana Alteva         & \texttt{gla2112} & \textit{Program Manager}  \\
Kunal Baweja           & \texttt{kb2896}  & \textit{Tester}
\end{tabular}
}

%% Generate the title
\maketitle

%% Table of contents
\tableofcontents{}

\chapter{Introduction}
  SOL (Shape Oriented Language) is a domain-specific programming language that allows programmers to create 2D animations with ease, through an object-oriented approach. Engineers, programmers, scientists and designers, through SOL, have the ability to define and create objects, known as Shapes, and dictate their appearance and movements on the screen. In addition, SOL\'s simplicity saves developers the trouble of learning complicated third-party animation tools, without sacrificing control over behavior of objects. It compiles into LLVM IR bytecode, making it adaptable across different architectures. The produced LLVM IR bytecode can be translated further into assembly code and linked statically against a predefined library before compiling down into an executable for a specific architecture using the LLVM compiler and GCC compilers respectively. The predefined library used by SOL for graphic rendering has been built on top of SDL2, which abstracts away the lower-level details for drawing and animating objects.

  \section{Background}
  SOL takes its inspiration from the ease of programming in the \textit{object-oriented paradigm} and the complexity of existing libraries/solutions for rendering graphics. It attempts to combine both of these and provide a language which allows developers to organize graphics into a collection of \textit{Shapes} (much like objects), which can be easily defined, created and interacted with to produce powerful images and/or animations in a fast-paced development environment.\\

  SOL is commonly used to model various types of scientific data, but it can also be applicable in other domains, such as:
  \begin{enumerate}
    \itemsep 0em
    \item Drawing engineering models
    \item Data visualization
    \item Bored college students making funny memes
    \item Entertaining animations
  \end{enumerate}

\chapter{Language Tutorial}
  This chapter provides a brief description of basic components of the language to guide programmers towards creating their first SOL program! It has been divided into three parts:
  \begin{enumerate}
    \item \textbf{Environment setup} - guide to setting up the SOL compiler and development environment
    \item \textbf{Language Quick Tour} - a brief description of basic components of the language
    \item \textbf{Sample Program} - Create dancing line bars
  \end{enumerate}

  \section{Environment setup}
  The SOL compiler has been developed and tested on Ubuntu 15.04 and Ubuntu 16.04 environments, and is capable of supporting others as well. It can work on multiple architectures as the LLVM IR bytecode can further be compiled into architecture-specific executables. The environment setup tutorial assumes you have the latest version of the SOL compiler source code downloaded from our repository.

    \subsection{Building SOL compiler (Ubuntu 15.04 or later version)}
    \begin{enumerate}
      \item The SOL compiler is written in OCaml. Download the source code from our github repository: \colorbox{lightgray}{{\href{https://github.com/bawejakunal/sol}{https://github.com/bawejakunal/sol}}}

      \item Download and run the bash script below, which installs the latest compatible version of the OCaml compiler and opam for *-nix OS environments.\\
      \colorbox{lightgray}{{\href{https://raw.githubusercontent.com/ocaml/ocaml-ci-scripts/master/.travis-ocaml.sh}{https://raw.githubusercontent.com/ocaml/ocaml-ci-scripts/master/.travis-ocaml.sh}}}

      \item Configure the opam environment for importing Ocaml packages\\
      \colorbox{lightgray}{\lstinline[style=bash]{eval `opam config env`}}

      \item Install the LLVM compiler toolchain and ocaml bindings, for the SOL compiler\\
      \colorbox{lightgray}{\lstinline[style=bash]{./install-llvm.sh}}

      \item Download and Install SDL2 and SDL2\_gfx libraries which are used by our predefined static library for graphics rendering.\\
        \colorbox{lightgray}{\lstinline[style=bash]{wget} \href{http://www.ferzkopp.net/Software/SDL2\_gfx/SDL2\_gfx-1.0.3.tar.gz}{http://www.ferzkopp.net/Software/SDL2\_gfx/SDL2\_gfx-1.0.3.tar.gz}}\\
        \colorbox{lightgray}{\lstinline[style=bash]{./install-sdl-gfx.sh}}

      \item Build the SOL compiler as \texttt{sol.native} and the static graphic library as \texttt{predefined.o}\\
      \colorbox{lightgray}{\lstinline[style=bash]{make all}}

    \end{enumerate}

  \section{SOL Quick Tour}
  This section provides a quick tour of the data types, data structures and the shape-oriented programming paradigm provided by SOL, with examples. Towards the end we walk through the steps to generate an executable SOL program. For a detailed explanation of language syntax, semantics and built-in functions, refer to chapter \ref{lrm}.

    \subsection{Primitive data types}
      All variables of primitive data types are declared starting with their type followed by an identifier. SOL supports the following primitives:
      \begin{enumerate}
        \itemsep 0em
        \item \texttt{int} - integers
        \item \texttt{float} - double-precision floating-point numbers
        \item \texttt{char} - single characters from the \texttt{ASCII} character set
        \item \texttt{string} - a sequence of one or more \texttt{ASCII} characters
      \end{enumerate}
      Example:\\
      \begin{lstlisting}[style=sol]
        func main() {
            int x;  /* declare primitives */
            float y;
            char c;
            string s;

            x = 5;  /* assign values to primitives */
            y = 6.5;
            c = 'a';
            s = "better call SOL";
        }
      \end{lstlisting}

    \subsection{Arrays and Shapes}
      SOL supports two complex data structures:
      \subsubsection{Array}
        An array is a fixed-size sequence of primitives or objects of a given \textit{shape}. Individual elements can be accessed within an array by specifying indices as integers in the range \texttt{0} to \texttt{1 less than array length}.\\
        Example:\\
        \begin{lstlisting}[style=sol]
          func main() {
              int [3]a;      /* declare array of 3 integers */
              a = [1, 2, 3]; /* init array with 3 elements*/
              a[1] = 4;      /* update second element value to 4 */
              a[2] = a[0];   /* last element equal to first element */
          }
        \end{lstlisting}

      \subsubsection{Shape}
        A collection of one or more variables/arrays of \textit{primitives and/or shapes} which come together to describe a \textit{shape}. These variables are called the \textit{member variables} of the shape. A shape definition can also contain function definitions, referred to as \textit{member functions}.\\
        Example:\\
        \begin{lstlisting}[style=sol]
          class Line {
              string name;  /* identify a line by name */
              int [2]start; /* first end point of a line */
              int [2]end;   /* other end point of a line */

              /* compulsory constructor for a shape */
              construct(int [2]s, int[2]e) {
                  /* constructor can be empty definition */
                  start = s;
                  end = e;
              }

              /* compulsory draw member function.*/
              draw() {
                  /* accepts no arguments */
                  /* can be empty definition */
              }
          }

          func main() {
              Line l; /* declare a variable of shape Line */
              l = shape Line([1,1], [2,2]); /* instantiate a Line object */
          }
        \end{lstlisting}

    \subsection{Operators}
    SOL supports \texit{arithmetic operations, relational comparisons and logical operations}. For all binary operators described in this section, the operands are specified from left and right, respectively, of the operator, and \textit{both operands must be expressions of the same data type}.\\
    All logical operators accept \textit{boolean logic expressions}, represented as \textit{integer expression} in SOL. Non-zero expressions correspond to \texttt{true} and a \texttt{zero} corresponds to \texttt{false}. 

    \begin{enumerate}
      \itemsep 0em
      \item \textit{Binary arithmetic operators}: \texttt{+, -, *, / \%}
      \item \textit{Relational operators (binary)}: \texttt{==, |=, >, >=, <, <=}
      \item \textit{Logical operators}: \texttt{\&\&, ||} \textit{(operands must be of type int)}
      \item \textit{Logical not}: \texttt{!} \textit{(unary and right-associative)}
      \item \textit{Unary negation}: \texttt{-} \textit{(unary and right-associative)}
    \end{enumerate}

    All expressions are evaluated from left to right. Please refer to section \ref{precedence} for the exact order of preference and associativity rules for each operator.\\

    Example:\\
    \begin{lstlisting}[style=sol]
        func main() {
            int x;
            int y;
            int c;
            float f;
            float g;

            x = 2;
            y = 3;
            f = 3.0;
            g = 6.0;

            y = x + y;  /*5: integer addition */
            x = y - x;  /*3: subtraction */

            g = g * f;  /* 18: floating point multiplication*/
            f = g / f;  /* 6: floating point division */
            y = y % 2;  /*1: modulo operation */

            c = g == f; /*0: EQUALITY is false */
            c = g != f; /*1: NOT EQUAL is true */
            c = g > f;  /*1: g GREATER THAN f */
            c = y >= x; /*1: y GREATER THAN OR EQUAL x is true */
            c = y < x;  /*0: y LESS THAN x is false */
            c = 5 <= 5; /*1: 5 LESS THAN OR EQUALS 5 is true */

            c = 5 && 0; /*0: LOGICAL AND of true and false */
            c = 2 || 0; /*1: LOGICAL OR of true and false */

            c = !c;   /*0: LOGICAL NOT of true(1) */
            f = -f;   /*-6: unary negation of arithmetic expression */
        }
    \end{lstlisting} 

    \subsection{Control flow statements}
    SOL program statements are executed in order, with the entry point being the main function. However, sometimes developers may need to execute only a branch of source code (jump through some statements) or execute a portion of code repeatedly. SOL provides two control flow statements - \textit{if) and \textit{while}, for conditional branching and looping through a portion of code, respectively.

      \subsubsection{if-statement}
      An \textit {if statement block} allow the execution or skipping of a \texit{code block} based on a \textit{logical expression}.\\
      Example:\\
      \begin{lstlisting}[style=sol]
        func main() {
          if (1 > 2) {
            /* condition if false; skip this code block */
            consolePrint("NOT PRINTED");
          }
          consolePrint("Hello World");
        }
      \end{lstlisting}

      \subsubsection{while-statement}
      A \texit{while statement block} allows the execution of a portion of source code repeatedly until a logical condition ()the predicate) is no longer satisfied.
      \begin{lstlisting}[style=sol]
        func main() {
            int i;
            i = 1;
            while (i <= 5) {
                consolePrint("Hello");  /* this loop prints Hello 5 times*/
                i = i + 1;    /* loop terminates when i exceeds 5 */
            }
        }
      \end{lstlisting}

    \subsection{Functions in SOL}
    In SOL, functions can be defined as a way to abstract away and re-use a code lock, with a named representation. These are useful if a particular piece of code needs to be executed at multiple places in the program. Functions in SOL can be defined as stand-alone functions or as \textit{member functions} of a \textit{shape} definition. Function definitions begin with the \texttt{func} keyword and they optionally accept arguments as input values and return a result, for which the result type needs to be indicated in the function definition. A function may return no value \textit{(void type)} in which case no return type should to be mentioned in the function definition. Please refer section \ref{function} for a detailed explanation of the function definition syntax.\\
    
    Example:\\
    \begin{lstlisting}[style=sol]
      /* define a function that accepts two integers and returns their sum */
      func int add(int x, int y) {
          /* sum of two integers */
          return x + y;
      }

      func main() {
          int sum;
          sum = add(2, 3);
          if (sum == 5) {
              consolePrint("CORRECT");
          }
      }
    \end{lstlisting}

    Functions in SOL also support recursion. SOL also provides a number of type conversion functions and built-in functions for displaying and animating shapes on the screen, and printing text on the screen or the console. Please refer to section \ref{internal} for detailed information on, and the syntax of, these functions.

  \section{Dancing Bars Tutorial (Sample SOL program)}
  The following program shows a simple definition of a \textit{dancing line} as a \textit{shape} and uses this definition to create a set of colored bars, that oscillate about one endpoint, at a given frequency.
  \begin{enumerate}
    \itemsep 0em
    \item As SOL treats all animation as an interaction of \textit{shapes}, we first define a thick line \textit{shape} in SOL, which can oscillate in length on one end.\\
    The constructor accepts four main arguments: \texttt{start point}, \texttt{end point}, \texttt{color} and \texttt{frequency} of oscillation.\\
    We define its \texttt{draw} function based on these input arguments.\\

    \begin{lstlisting}[style=sol, aboveskip=1pt]
      shape DanceLine {
          int [2]start;
          int [2]end;
          int [3]color;
          int freq;   /* oscillation frequency */
          int cnt;
          int d;      /* length change per iteration */

          /* constructor */
          construct(int [2]s, int [2]e, int[3]clr, int f) {
              start = s;
              end = e;
              color = clr; 
              freq = f;   
              cnt = 0;    /* initial counter */
              d = 2;  
          }

          /* drawing specification for single frame */
          draw(){
              int i;
              int [2]s;   /* control points for drawCurve */
              int [2]m;
              int [2]e;

              /* increment count on each frame */
              cnt = cnt + 1;

              if (cnt > freq) {
                  d = -d;     /* reverse direction */
                  cnt = 0;    /* reset freq counter */
              }

              /* change object length on one end */
              end[1] = end[1] + d;

              s = start;  /* end points of line */
              e = end;

              /* draw 10 bezier curves for thickness */
              i = 0;
              while (i < 10) {
                  s[0] = s[0] + 1;
                  e[0] = e[0] + 1;

                  /* bezier curve mid point */            
                  m[0] = (s[0] + e[0]) / 2;
                  m[1] = (s[1] + e[1]) / 2;

                  /* draw straight bezier curve */
                  drawCurve(s, m, e, 2, color);
                  i = i + 1;
              }
          }
      }
    \end{lstlisting}

    \item The next step is to create a collection of multiple \textit{DanceLine} instances, say \textit{DiscoBar}. Hence, we define a new \texttt{shape}, \textit{DiscoBars} that defines three variables of \texttt{shape} \textit{DanceLine}. In the constructor, we instantiate the \textit{member variables} with different colored lines, oscillating at different frequencies.\\

    \begin{lstlisting}[style=sol, aboveskip=1pt]
      shape DiscoBars {
          DanceLine d1;   /* member variables */
          DanceLine d2;
          DanceLine d3;

          construct () {
              /* instantiate DanceLine member variables */
              d1 = shape DanceLine([100,300], [100,252], [30,144,255], 20);
              d2 = shape DanceLine([130,300], [130,202], [210,105,30], 40);
              d3 = shape DanceLine([160,300], [160,132], [50,205,50], 80);
          }

          draw(){
              /* empty draw function 
               * draw functions of member variables
               * are called implicitly
               */
          }
      }
    \end{lstlisting}
  
    \item As a final step, we need to create one object of the \textit{DanceBars} shape in the \textit{main} function, which is the entry point of a SOL program. The SOL runtime will iteratively call its \textit{draw} function - and the \texttt{draw} functions of its member variables - for each frame, to display the oscillating lines.\\

    \begin{lstlisting}[style=sol, aboveskip=1pt]
      func main() {
          DiscoBars bars;
          bars = shape DiscoBars();
      }
    \end{lstlisting}
  \end{enumerate}

  Your final output on screen should look like the image shown below, with the colored bars \textbf{oscillating in length, at their upper ends}, at different frequencies.\\
  \begin{center}
      \includegraphics[scale=1]{dancing-bars.png}\\
      \caption{Fig 2.1 DiscoBars Tutorial}
  \end{center}


\chapter{Language Reference Manual} \label{lrm}

  %% include the common content for lrm
  \input{../lrm/sol-lrm-content.tex}

\chapter{Project Plan}

  This chapter details the project development, testing process, time-lines, milestones, and roles and responsibilities of each team member.

  \section{Project Development Process}
  Throughout the SOL compiler development process we tried to stick as closely as possible to in-lecture instructions and suggestions given by instructor, Prof. Stephen A. Edwards, and our project mentor Connor Abbott. The four major phases of project development are described in the following sections.

    \subsection{Planning}
      Once the team decided on addressing easy animations through an object-oriented programming language, we quickly got down to listing as many features as we could think of with respect to graphics animation. As Aditya Narayanamoorthy \textit{(Language Guru)} had taken a Computer Graphics course previously, he helped us pick out the most basic and necessary features for the language, such as using \textit{B\'ezier curves} to describe shapes in our language. We tried to narrow down the minimal number of language features that would allow a SOL programmer to describe, display and animate a shape on screen using SOL. In case of a disagreement on the features to be included, the final call was taken by the \textit{Language Guru}. All the decided features are detailed in the SOL Language Reference Manual (chapter \ref{lrm}), which every team member used as a reference point for the rest of the project development and testing phases.\\

      In our planning phase we also decided on the software development process, including division of work based on each member's expertise, discussed time availabilities, tools and development environments to use, summarized below:
      \begin{enumerate}
        \itemsep 0em
        \item We scheduled two days per week for 3 hour long meetings for the team to work together on the project.
        \item WE chose Github as the version control system for our project, in conjunction with Slack for team communication.
      \end{enumerate}

    \subsection{Specfication}
      For specifying the exact feature details, we required a lightweight graphics library that would interface with the graphics back-end and link well against the LLVM compiler output, and develop a good understanding of its working. Erik, the systems architect, tried out a few graphics library and suggested using SDL2, primarily because of its ease of use for rendering simple graphics on screen, and its bindings to multiple languages including C, C++ and OCaml.\\

      The next major specification step for SOL was to decide on how to represent and render shapes. Aditya, our Language Guru, suggested that all shapes be expressed as a combination of B\'ezier curves and hence the basic units of drawing in SOL, available to a programmer should be the \texttt{drawPoint} and \texttt{drawCurve} functions to draw shapes, along with \texttt{translate} and \texttt{rotate} functions to animate the drawings io a 2D plane. To accomplish drawing B\'ezier curves, on top of SDL2, we chose the SDL2\_gfx library which was compiled and integrated into the development environment by Kunal and Erik.\\

      Throughout the compiler development, we asked our mentor Connor Abbott for advice on how to prioritize  and implement features crucial for SOL, like fixed-size arrays v/s dynamic arrays, or advantages of using an SAST over a simple AST. During the development phase we also realized that some of the features that we had originally planned for SOL were not quite straightforward to implement, or differed from our initial understanding. This made us modify some specific components of the language, which we updated in the Language Reference Manual and testing suite, after consulting with our mentor.

    \subsection{Development and Testing}
      We followed a \textit{test-driven development} approach for SOL as far as possible. Initially test cases were written based on the features mentioned in our programming language reference manual. Test cases were divided into two main categories: features that are allowed in SOL, such as integer addition, defining shapes etc, and failure cases which check whether the compiler properly rejects syntactically or semantically incorrect programs. Each test case comprised of a basic SOL program source code that would test one particular feature or component of the language and compare the actual output against an standardized file containing expected output messages.\\

      The compiler was built by integrating one feature at a time, end to end, starting at the scanner, all the way up to the codegen phase. This would allow the compiler to support that feature alongside previously-implemented features. Each feature implementation was tested against the test suite to ensure correct behavior and also to ensure that it does not break any of the previously-implemented features, using the testing script and Travis CI builds that were triggered on each code push to our Github repository.\\
      Aditya and Gergana worked heavily on the compiler and met frequently outside of scheduled team meetings to pair-program and ensure the on-time delivery of components.\\

      Towards the end of project development timeline, we also incorporated a manual testing component, as there is no way to ensure correct display of graphics within Travis CI environment. These tests can be run using the same test suite script, with manual inspection of displayed graphics to ensure correctness.\\

  \section{Programming Style Guide}
    \begin{itemize}
      \itemsep 0em
      \item Most of our compiler source code is written in OCaml; we simply used the standard Ocaml programming guidelines as mentioned on the official tutorials page\\
      \colorbox{lightgray}{\href{https://ocaml.org/learn/tutorials/guidelines.html}{https://ocaml.org/learn/tutorials/guidelines.html}}

      \item To enforce OCaml style guides, Kunal set up the open-sourced merlin linter and analyzer in sublime text editor\\
      \colorbox{lightgray}{\href{https://github.com/let-def/sublime-text-merlin}{https://github.com/let-def/sublime-text-merlin}}

      \item A significant component of the SOL compiler is the \textit{predefined.o} static library written in C (C99 standard) for which the C++ linter was used within sublime text.\\
      \colorbox{lightgray}{\href{ https://github.com/SublimeLinter/SublimeLinter-cppcheck}{ https://github.com/SublimeLinter/SublimeLinter-cppcheck}}

      \item As a general rule of thumb, we tried to use descriptive variable names throughout our code, which helps the reader to easily understand the code.
    \end{itemize}

  \section{Project Timeline}
    \subsection{Milestones}
      \begin{center}
        {\renewcommand{\arraystretch}{1.5}
        \begin{tabular}{|p{8cm}|p{4cm}|}
        \hline
          \textbf{Milestone} & \textbf{Date} \\
          \hline
          Initial research \& brainstorming & Sept. 11 \\
          \hline
          Decide on language idea & Sept. 19 \\
          \hline
          Finish Proposal & Sept. 26 \\
          \hline
          Finish LRM & Oct. 16 \\
          \hline
          Add regression test suite/Travis CI & Oct. 29 \\
          \hline
          Implement primitives \& other basics & Nov. 1 \\
          \hline
          Hello World Demo & Nov. 8 \\
          \hline
          Implement arrays, internal functions & Dec. 2 \\
          \hline
          Implement shapes & Dec. 12 \\
          \hline
          Implement drawing (SDL) & Dec. 16-17 \\
          \hline
          Update and Finish Testing (manual) & Dec. 17-19 \\
          \hline
          Final Report Preparation & Dec. 18-19 \\
          \hline
          Demo Day & Dec. 20\\
        \hline
        \end{tabular}
      \end{center}

    \subsection{Github timeline}
      \includegraphics[scale=0.37]{github-timeline}

  \section {Team Roles and Responsibilities}
    The following table summarizes the major responsibilities taken up by each team member, with a number of components overlapping among team members.
    \begin{center}
      {\renewcommand{\arraystretch}{1.5}
      \begin{tabular}{|p{5cm}|p{10cm}|}
      \hline
      \textbf{Team Member} & \textbf{Responsibilities} \\
      \hline
      Aditya Narayanamoorthy (Language Guru) & Scanner, Parser, Ast, Semant, Sast, Codegen \\
      \hline
      Gergana Alteva (Project Manager) & Scanner, Parser, Ast, Semant, Sast, Codegen \\
      \hline
      Erik Dyer (System Architect) & VM, Docker, Graphics Library researching (SDL2), testing \\
      \hline
      Kunal Baweja (Tester) & predefined library, SDL2, SDL2\_gfx, Automated and Manual Test suite, Travis CI \\
      \hline
      \end{tabular}
    \end{center}

  \section{Software Development Environment}
    The following software development tools, libraries and dependencies were used for developing the SOL compiler by the team.
    \begin{enumerate}
      \itemsep 0em
      \item Ubuntu \texttt{15.04} VM setup with ocaml compiler, opam, llvm toolchain, and ocaml Llvm module for llvm bindings.
      \item Ocaml version: \texttt{4.02.3}
      \item LLVM dev library: \texttt{3.8}
      \item opam Llvm package (Ocaml Llvm bindings)
      \item Sublime text with \texttt{merlin(ocaml)} and \texttt{cppcheck(C99)} linters
      \item Version Control: \texttt{Github}
      \item Travis CI: Automated testing on \texttt{Ubuntu 16.04} environment (same dependency configurations)
    \end{enumerate}

  \section {Project Logs}
  Please see appendix \ref{git:log} for project logs in reverse chronological order.

\chapter{Architectural Design}
  We describe the compilation structure for a SOL program through the SOL compiler in this chapter. This can be broken down into 3 phases:
  \begin{enumerate}
    \itemsep 0em

    \item Compile SOL program to LLVM IR bytecode representation
    \item Compile generated IR to architecture specific assembly code using LLVM compiler
    \item Compile and link against predefined static library to produce executable
  \end{enumerate}

  \begin{figure}[ht]
    \includegraphics[scale=1]{compile-architecture.png}
    \caption{SOL Compiler Block Diagram}
  \end{figure}

  \section{Interfaces between SOL Compiler components}
    \subsection{Scanner}
      The scanner takes as input a \texttt{SOL(.sol) source program} and generates tokens for \textit{identifiers, keywords, operators, values, functions and shapes}, as specified by the lexical conventions for SOL in the Language Reference Manual (see chapter \ref{lrm}). It rejects a source program if it observes an invalid token, using the rules specified in \texttt{scanner.mll}

    \subsection{Parser}
      The parser accepts the tokenized output from the scanner and generates an abstract syntax tree (AST) based on SOL syntax. It rejects the source program if a syntactic error is seen (due to which a valid AST cannot be generated).

    \subsection{Semantic Checker}
      The AST output from parser is passed to the semantic checker to ensure semantic correctness of each program statement, including static type checking. Eg: An \texttt{int} variable cannot be assigned a floating point value, per SOL specification. Such an assignment in SOL program will be semantically incorrect and rejected at the semantic checking phase.\\
      The semantic checking phase associates semantic information to the AST nodes and produces an SAST (Semantically-checked AST) if the program passes this phase.

    \subsection{Code Generation}
    The code generator accepts the SAST generated after semantic checking and generates the LLVM IR code using the OCaml Llvm bindings. The SOL \textit{primitives, arrays, shapes, functions, member functions} are all mapped to corresponding LLVM primitives, arrays, structs and function definition representations.\\
    Once the LLVM IR code is generated successfully, the SOL compiler task is over. After this we use the LLVM compiler (\texttt{llc}) to convert the IR code to architecture-specific assembly code. This is further compiled into an executable and statically linked against a predefined library that interfaces with \texttt{SDL2} and \texttt{SDL2\_gfx}. 

    The compiler components were implemented by team members as listed below:
    \begin{center}
      {\renewcommand{\arraystretch}{1.5}
      \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
        \hline
        \textbf{Component} & \textbf{Source file} & \textbf{Team members} \\
        \hline
        Lexical Analysis & scanner.mll & Aditya, Gergana\\
        \hline
        Parsing & parser.mly & Aditya, Gergana\\
        \hline
        Abstract Syntax Tree & ast.ml & Aditya, Gergana\\
        \hline
        Semantic Analysis & semant.ml & Aditya, Gergana\\
        \hline
        SAST & sast.ml & Aditya, Gergana\\
        \hline
        LLVM backend & codegen.ml & Aditya, Gergana\\
        \hline
        Predefined graphic library & predefined.c & Kunal\\
        \hline
      \end{tabular}
    \end{center}

\chapter{Test Plan}
The SOL compiler was developed through a test-driven development approach. 

  \section{Sample Programs}
  This section shows 3 sample programs written in SOL and corresponding LLVM IR code represtation generated for the source programs.
    \subsection{Recursive function}
    The following program shows a SOL program to print sum of natural numbers from 1 to \texttt{n}, where \texttt{n} is input to the program.

    \subsubsection{series.sol}
    \lstinputlisting[style=sol, aboveskip=2pt]{series.sol}

    \subsubsection{series.ll}
    \lstinputlisting[style=sol, aboveskip=2pt]{series.ll}

    \subsection{Composite Shape Drawing}
    The following program demonstrates construction of complex shapes in SOL. It defines two generic shapes, \texttt{Polygon} and \texttt{Spokes}. Further it uses \texttt{Polygon} to define a \texttt{Square} and defines a \texttt{FerrisWheel} shape using member variables of \texttt{Polygon}, \texttt{Square} and \texttt{Spokes} shapes. In the \texttt{draw} function of \texttt{FerrisWheel} we define the logic to draw the object at each frame, gradually speeding up the rotation speed, staying constant at that speed and then slowing down to a halt.

    \subsubsection{ferris-wheel.sol}
    \lstinputlisting[style=sol, aboveskip=2pt]{ferris-wheel.sol}

    \subsubsection{ferris-wheel.ll}
    \lstinputlisting[style=sol, aboveskip=2pt]{ferris-wheel.ll}

    \subsection{Animating Shapes}
    In this sample program, the introduction scene from the \texit{James Bond} movie franchise is recreated, again by defining two basic shapes, \texttt{Polygon} and \texttt{Line}. These shapes are used to create circles for the screen and additionally define a \textit{Person} shape. For each of the objects created, a render block is defined which dictates the translation of individual objects.

    \subsubsection{james-bond.sol}
    \lstinputlisting[style=sol, aboveskip=2pt]{james-bond.sol}

    \subsubsection{james-bond.ll}
    \lstinputlisting[style=sol, aboveskip=2pt]{james-bond.ll}    

  \section{Test Suite}
    The test suite is divided into two major categories:
    \begin{itemize}
      \itemsep 0em
      \item Automated Tests - run on Travis CI
      \item Manual Tests - visually inspected for display correctness
    \end{itemize}

    \textbf{NOTE:} Please refer to \underline{Appendix \ref{test-suite}} for complete code listing of the test cases.\\

    Test cases were written based on the syntactic and semantic specifications of the language mentioned in the SOL Language Reference Manual (chapter \ref{lrm}). This acted as a reference point for the team and allowed us to stay as close to the LRM specifications as practically possible throughout the compiler development process.\\

    The initial tests for each feature were written as \textit{functional tests} which would ensure the correct working of the feature once it was implemented and integrated into the compiler. Once the feature was integrated  the compiler, it was put through the complete list of tests (automated), to ensure that the new changes did not adversely affect any of the previously-implemented features, and to verify that as part of the language, each individual feature works in a certain expected manner without any conflicts.\\

    We tested the following major components of our language, crucial for SOL:
    \begin{itemize}
      \itemsep 0em
      \item \textit{primitives} - The tests cover declaration and assignments of primitive variables extensively, through specific test cases for assignment, operations, declarations, scoping rules and static type checking.

      \item \textit{Arrays} - Fixed-size arrays of primitives are supported by SOL and hence we extensively tested for array declaration, assigning and accessing individual elements. SOL does not provide bounds checking, much like C and hence it is the programmer's responsibility to ensure this.

      \item \textit{Shapes} - Defining shapes for drawing and animation on screen is the basic feature of the object-oriented paradigm supported by SOL. We tested defining, instantiating and animating shapes through multiple automated and manual test cases, for visual correctness of rendered drawings. This includes defining and creating complex shapes using simpler shape definitions.

      \item \textit{Operations} - SOL allows basic arithmetic and logical operations on integers and floating point numbers and these have been tested with respect to order of precedence and associativity rules in an expression, alongside correctness of the result outputted by each individual operation.

      \item \textit{Functions} - SOL supports declaring functions, both standalone as well as member functions of a shape. These have been tested by checking for return types, values, recursion, expected number of arguments and argument types, syntactic correctness and expected failures in case of incorrect source programs.

      \item \textit{Type Conversion} - SOL allows converting, \texttt{int}, \texttt{float} and \texttt{char} values to \texttt{string} through appropriate functions mentioned in the Language Reference Manual and tested via \texttt{consolePrint} and \texttt{print} function calls.

      \item \textit{Drawing Function} - Three basic drawing functions are provided as built-ins by SOL for rendering text and shapes on screen. These have been tested through manual test cases, wherein a visual inspection of displayed content is required to ensure correctness.

      \item \textit{Output Function} - Apart from the drawing functions mentioned above, the only output function provided is \texttt{consolePrint}} which outputs the \texttt{string} argument to standard output; this is tested by comparing the outputs against expected outputs of the corresponding test programs.

      \item \textit{Animation Function} - The \textit{translate} and \textit{rotate} functions are the basic components that allow a SOL programmer to animate objects and these have been tested for intended behavior rigorously, to account for intended and possible unintended side-effects of the program written.
  \end{itemize}

  \section{Test Automation}
    We used \textit{Travis CI} in conjunction with the \texttt{testall.sh} script (see \ref{test-suite}) for automatically running all test cases and checking outputs against the expected output from the compiled program, or failure during compilation or runtime of the program. Setting up Travis CI allowed us to run the complete regression test suite in a standardized development environment, for every code push to the github repository, without manual intervention, and to be notified in case of test failures.

  \section{Manual Testing}
    Testing shape display and animation correctness was not possible within \texit{Travis CI} environment as it does not support a display console for testing. These test cases were written separately, in test files following naming pattern \texttt{mnl-*}, compiled and run using the same test script, although these required manual intervention for correctness of displayed graphics. Please see Appendix \ref{mnl-test} for manual test cases.

  \section{Testing Responsibilities}
  \begin{center}
    {\renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|p{5cm}|p{8cm}|}
      \hline
      \textbf{Team member} & \textbf{Responsibilties}\\
      \hline
      Kunal Baweja (Tester) & Test Plan, Travis CI/Automation, Test environment setup, Writing regression \& unit tests\\
      \hline
      Erik Dyer (System Architect) & Writing regression \& unit tests\\
      \hline
    \end{tabular}
  \end{center}

\chapter{Lessons Learned}
  
  \section{Aditya Narayanmoorthy}
	This was a great (though tough) experience as a course project, and I definitely learned a lot - both about compilers and about the importance of having a good team. I was lucky enough to get great teammates with whom I worked fairly regularly, and that helped a lot with integrating features smoothly, and making sure they work as they're supposed to.\\

    I'd advise future groups to keep ahead of the lectures in class - the sooner you get comfortable with OCaml, the faster you can implement the language that you want (especially if you don't have much experience with functional programming languages). Additionally, it helps to get comfortable with how LLVM and its OCaml implementation work - writing code in this can be cumbersome at times, but it's powerful enough to do a lot of things. Lastly, I would suggest prioritizing important language features early, as this helps getting clarity in your vision for the language.

  \section{Erik Dyer}
    This semester I learned how important organization and communication is. I think one thing that was really good about our team is that we were very good about sticking to meeting frequently from the beginning. Having this organization from the beginning allowed us to avoid the ``who\'s free to meet when ?" dance and therefore build up an early momentum that was sustained throughout the semester.\\

    I think that one piece of advice I'd give to future groups is to think about what kind of language you could build from before you take the class. Our group took several meetings before we decided what kind of language we wanted to have, and that\'s before we even got to the language details. Coming in with a language idea will definitely be helpful and save time.

  \section{Gegana Alteva}
    Building a compiler in a team has provided me with many lessons throughout the semester. My development experience is limited and while I had an understanding of what needed to be done, I was not sure how it should be done. I learned the importance of implementing our language vertically and how to prioritize components. My advice for future teams would be to prioritize what needs to be implemented by understanding what is absolutely needed for your language to work. There are many language design aspects that seem necessary, but in reality are just \"nice-to-have\"s. Had I done a better job of prioritizing and classifying what is and is not a \"nice-to-have\", we would have perhaps spent more time coding what was actually needed.

  \section{Kunal Baweja}
    Through PLT project, I learned the importance of prioritizing tasks and thorough integration tests, which were both essential throughout the SOL compiler project. We worked on the compiler every week, making steady progress throughout the semester, picking one major task at a time and our team manager ensured that we stayed organized and on course throughout, highlighting the importance of good management skills.\\

    For the future teams taking PLT class I would advise to pay close attention to the content going into Language Reference Manual, that you submit at the beginning of the semester. It will act as the north star for your team, working on the compiler throughout rest of the semester. Make the LRM  concrete, including the tiniest details like syntax and semantics of internal functions and features as much you can to avoid getting into situations where you are not clear on what a particular feature should do or what its syntax should be. This will help you save a lot of time and energy and allow you to concentrate on stronger features.

% Appendix code listings
\begin{appendices}

\chapter{SOL Compiler}

Code listing for compiler code. Author names are mentioned as first comment line of each code listing.

    \section{scanner.mll}
    \lstinputlisting[style=caml]{../scanner.mll}

    \section{parser.mly}
    \lstinputlisting[style=caml]{../parser.mly}

    \section{ast.ml}
    \lstinputlisting[style=caml]{../ast.ml}

    \section{semant.ml}
    \lstinputlisting[style=caml]{../semant.ml}

    \section{sast.ml}
    \lstinputlisting[style=caml]{../sast.ml}

    \section{codegen.ml}
    \lstinputlisting[style=caml]{../codegen.ml}

    \section{sol.ml}
    \lstinputlisting[style=caml]{../codegen.ml}

    \section{predefined.h}
    \lstinputlisting[style=caml]{../predefined.h}

    \section{predefined.c}
    \lstinputlisting[style=caml]{../predefined.c}

    \section{Makefile}
    \lstinputlisting[style=make]{../Makefile}


\chapter{Environment Setup}

The following scripts can be used for installing dependencies and setting up the environment.

    \section{install-llvm.sh}
    \lstinputlisting[style=bash]{../install-llvm.sh}

    \section{install-sdl-gfx.sh}
    \lstinputlisting[style=bash]{../install-sdl-gfx.sh}

\chapter{Automated testing}\label{test-suite}

The first two scripts are used for automated testing on Travis CI. For individual test cases, the author names are mentioned as the first line of each test case.

    \section{.travis.yml}
    \lstinputlisting[style=bash]{../.travis.yml}

    \section{testall.sh}
    \lstinputlisting[style=bash]{../testall.sh}

    %% include latest set of automated test files
    %% use g.py scrip to generate the test-case.tex
    %% recompile the latex document
    \input{test-cases.tex}

\chapter{Manual Testing}\label{mnl-test}

  \input{manual-test.tex}

\chapter{Commit Logs} \label{git:log}
  \lstinputlisting[style=make, stringstyle=\color{black}]{commit.log}

\end{appendices}

\end{document}
